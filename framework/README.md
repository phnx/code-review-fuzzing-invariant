# A Framework for Likely Invariant Analysis

This framework analyzes likely invariant at the selected program points to identify the potential behavioral differences between two program versions. Likely invariant represents the properties that always hold true at a certain program states. The deviations of likely invariants under the same program inputs indicate the potential shift of program behaviors that may imply the unexpected behavioral changes, or the in worst case, a vulnerability. 

To analyze likely invariants, the framework leverages the non-crahsing inputs generated by fuzzing tools. In particular, it can analyze behaviors of the program in the versions before and after the code changes proposed by a developer. This behavioral information aims  to support reviewers in understanding code context during the code review activity. The fuzzing tools serve as the powerful input generators for exploring the input space and revealing the subtle changes that may not result in crashes normally detected by the fuzzing techniques.




## Overview
The framework consists of multiple steps that can be tailored to fit different project's needs. The entire workflow is as follows:
- **Binary Building**
  - **Fetching target program**: download the target program and checkout two target versions (before and after changes)
  - **Manage target program dependencies**: install required packages to build and execute target program
  - **Building target binary**: compile two versions of the target program, with the configurations to allow binary debugging
- **Fuzzing and Analysis Preparation**
  - **Fuzzing**: fuzz the new version of program and collect non-crashing inputs from the input queue
  - **Identifying target breakpoints and variables**: select the target program points and variables affected by the code changes for observation, all must be available in both versions
- **Likely Invariant Analysis**
  - **Execution trace generation**: execute the program ussing collected inputs and extract execution trace of the same inputs in two program version, using [LLDB](https://lldb.llvm.org/)
  - **Likely invariant mining**: infer likely invariant set from each execution trace at the selected breakpoints of each program version, using [DIG](https://github.com/dynaroars/dig)
  - **Likely invariant distance measuring**: measure the differences of two likely invariant sets from the same input in two program versions at the same breakpoint
  - **Likely invaraint distance analysis**: analyze the distribution of distance measures and flag the breakpoints where multiple measures report the non-zero differences



## Setup
The framework operates in a Docker container.  It has been tested on Ubuntu 20.04 and Docker 23.0.6.

### Host Structure
The following paths on host machine store persistent data outside the operating container, some storing information can be reused.

- **program** - a path to store peripheral programs i.e., fuzzing tools and likely invariant miner
- **script** - a path to store all framework scripts
- **subject_data** - a path to store subject-specific scripts i.e., fetching script, dependency script, and build script; analysis information i.e., breakpoints, breakpoint variables; fuzzing inputs, and analysis results 


### Build Docker Image
Multiple dependencies must always be installed into the container. To reduce installation time, a docker image with all dependencies pre-installed can be built and re-used for instantiating a new container.

```shell
cd docker
docker build -t fuzzing-inv --build-context script=../script  .
```

### Starting Docker Container
The framework runs in a Docker container to control the environment. The container connects to the host for accessing scripts releated to framework and subject and store the results and outcomes from each step. Following commands can be used to start a container with the certain paths attached to the host.

```shell
# interactive mode
docker run --rm -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
    -v ${PWD}/subject_data:/subject_data \
    -v ${PWD}/script:/script:ro \
    -v ${PWD}/program:/program \
    -w /workdir \
    fuzzing-inv \
    bash

# batch mode, using script/entrypoint.sh with a selected FUZZING_TOOL
# see Section Subject Integration and Usage for setup steps
docker run --rm -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
    -v ${PWD}/subject_data:/subject_data \
    -v ${PWD}/script:/script:ro \
    -v ${PWD}/program:/program \
    -e FUZZING_TOOL="libfuzzer" \
    -w /workdir \
    fuzzing-inv \
    /script/entrypoint.sh
```

### Installing Likely Invariant Mining Tool [REQUIRED]
DIG must be install on the host machine through the container. This step is **required ONCE** to install DIG in the persistent `program` folder. It can be reused in subsequent containers afterwards.
```shell
source /script/install-dig.sh
```


### Subject Integration
Three scripts are required for integrating new test subject: `repo_fetch.sh`, `subjet_dep.sh`, and `build.sh`. They must be setup once to integrate the target subject to the framework. The examples can be seen in [subject_data](subject_data) and [RQ2 experiment_data](../experiment/rq2/experiment_data). 

- **`repo_fetch.sh`** clones target versions of the subject program to temporaty paths in container. It can also download other relevant files such as fuzz target, seeds, or downloadable dependencies.
- **`subject_dep.sh`** installs dependencies required for building the target binaries.
- **`build.sh`** compiles two versions of the subject (commits specified following [Usage](#usage)) and prepare initial seeds (if also fuzzing the target)


### Fuzzing Tool Integration
This section explains the process to install fuzzing and likely invariant mining tools. There is no limit for the choice of fuzzing tools and techniques to be integrated with the framework. Below are the installation commands for three fuzzing tools used in our experiments. Once the tools are build and installed in a persistent folder on host machine, they can be reused in the subsequent containers. 

For each fuzzing tool, the subject's `build.sh` and `fuzz.sh` must be modified to accommodate the tool's specific configurations and executions.

#### Install AFLplusplus
```shell
cd /program
git clone https://github.com/AFLplusplus/AFLplusplus.git
cd AFLplusplus
git checkout v4.21c

# clang is already updated
apt-get update
apt-get install -y build-essential python3-dev automake cmake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools cargo libgtk-3-dev
apt-get install -y gcc-$(gcc --version|head -n1|sed 's/\..*//'|sed 's/.* //')-plugin-dev libstdc++-$(gcc --version|head -n1|sed 's/\..*//'|sed 's/.* //')-dev
apt-get install -y ninja-build # for QEMU mode
apt-get install -y cpio libcapstone-dev # for Nyx mode

# unicorn will fail, but all necessary modules will be built
make distrib
```
#### Install Honggfuzz
```shell
cd /program
git clone https://github.com/google/honggfuzz.git
cd honggfuzz
# use this commit to overcome build issue https://github.com/google/honggfuzz/issues/490
git checkout 4c8517383e8070f6d8d0308253e4b33d11605c98\

# install Honggfuzz dependencies
apt-get install -y binutils-dev libunwind-dev libblocksruntime-dev clang
make
```

#### Install libFuzzer
*libFuzzer is automatically updated along with LLVM during container preparation.*




## Usage
The framework operates in multi-stages which can be wrapped as a single workflow or split and re-arranged to fit with particular project's requirements. For example, the fuzzing step can be skipped if fuzzing is done by other fuzzing frameworks as long as the non-crashing inputs are collected in the designated path and update `$BIC_INPUT_QUEUE_PATH` in the entrypoint script.

### Starting Main Workflow
The example of main script that executes every step in the workflow in [Overview](#overview) is provided in `script/entrypoint.sh`. Indeed, the script can be modified to skip some steps that may be executed externally, such as fuzzing. The entrypoint script can start in batch mode, with a selected `FUZZING_TOOL` shown in [Starting Docker Container](#starting-docker-container), or in interactive mode after entering the container as shown below.

```shell
export FUZZING_TOOL=aflplusplus
source /script/entrypoint.sh
```

The example `entrypoint.sh` executes all steps to analyze a pair of commits in [libhtp](https://github.com/OISF/libhtp/).

### Specifying Target Commits
Before starting the workflow, a pair of code commits that will be fetched and analyzed must be specified in [`target_commits.env`](subject_data/target_commit_info/target_commits.env). Both commits' SHA must be present in the repository used in `repo_fetch.sh`.

### Preparing Breakpoints
The following files and folder in `subject_data/target_commit_info` must be updated to select the code location(s) and variables for likely invariant analysis.
- **`bfc_breakpoints`** defines breakpoints in **prior** commit version on each line. Multiple breakpoints can be set.
- **`bic_breakpoints`** defines breakpoints in **new** commit version on each line. Multiple breakpoints can be set.
- **`breakpoint_variables`** contains multiple files that indicate the variables observed at each breakpoint location in both program versions. File's name indicates the order of breakpoint in the breakpoint file (starting from zero). A variable is listed on each line. 


### Result Reports
Flagged breakpoints are reported in `invariant_score_suggestion` within the respective path of `$INVARIANT_SCORE_PATH`.

###  Parameters
Some parameters in the framework can be customized to fit with project's resources in [`framework_config.env`](script/framework_config.env). In particular, following parameters can be adjusted.
- Fuzzing duration
- Timeout for execution trace generation
- Timeout for DIG likely invariant analysis
- Maximum likley invariants analyzed per breakpoint

